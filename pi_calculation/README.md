### **Постановка проблемы**

Данная работа является реализацией решения следующей задачки, которая
показалась мне занимательной[1]:

<center>
*“У вас есть функция генерации случайных чисел из равномерного
вероятностного распределения. Рассчитайте число *π*.”*
</center>

Соответственно, для решения задачи в R, нам необходимо пользоваться
исключительно функцией *runif* (**r**andom **unif**orm distribution).
Однако перед показом непосредственно самого решения, я пошагово и с
помощью графиков (для наглядности) покажу саму идею решения. На этом
этапе я буду пользоваться любыми функциями.

### **На пути к решению проблемы**

Создадим два вектора *x* и *y* по 10 случайных значений в каждом, в
области значений от -1 до 1.

    set.seed(11)
    x <- runif(10, -1, 1)
    y <- runif(10, -1, 1)
    cbind(x, y)

    ##                 x           y
    ##  [1,] -0.44550041 -0.64977415
    ##  [2,] -0.99896337 -0.11849946
    ##  [3,]  0.02121675  0.81436595
    ##  [4,] -0.97190418  0.70208373
    ##  [5,] -0.87062045  0.46797499
    ##  [6,]  0.90969845  0.14737144
    ##  [7,] -0.82700822 -0.03646893
    ##  [8,] -0.42004998 -0.33877801
    ##  [9,]  0.76139835 -0.68467950
    ## [10,] -0.75356760 -0.03973189

Значения векторов можно представить как координаты для 10 точек
соответственно. Причем они не могут выйти за пределы *x* ∈ \[ − 1; 1\] и
*y* ∈ \[ − 1; 1\]. Расставим точки на графике, а обозначенные
ограничения отразим с помощью квадрата (со стороной, равной,
соответственно 2):

    data <- data.frame(x = x, y = y)
    graph <- ggplot(data, aes(x, y)) +
        geom_point(color = "blue") +
        geom_rect(aes(xmin = -1, ymin = -1, ymax = 1, xmax = 1),
                  color = "black",
                  fill = NA)
    graph

<img src="pi_calculation_files/figure-markdown_strict/unnamed-chunk-4-1.png" style="display: block; margin: auto;" />

Теперь построим окружность с центром, совпадающим с центром координатной
плоскости, и с радиусом 1. Интересно, что ggplot2 не имеет готовый geom
для построения окружностей, поэтому с небольшой помощью StackOverflow
предварительно определим функцию для создания координат окружности[2]:

    circleFun <- function(center = c(0,0), r = 1, npoints = 100) {
            tt <- seq(0,2*pi,length.out = npoints)
            xx <- center[1] + r * cos(tt)
            yy <- center[2] + r * sin(tt)
            return(data.frame(x = xx, y = yy))
    }

**NB!** Обратим внимание, что внутри только что определенной функции мы
все-таки обратились к числу *π*!! Это можно оправдать тем, что именно
это число *π* мы используем только для того, чтобы нарисовать окружность
(в целом, это не необходимо для построения окружности на бумаге с
карандашом/циркулем). Но это, возможно, не самый убедительный аргумент.
Самый главный состоит в том, что все графики здесь – это всего лишь
демонстрации идеи, которая чуть позже будет определена математически
(как я и обещал в самом начале!). Без круга можно легко обойтись, а на
этапе он служит лишь наглядности.

Строим окружность к предыдущему графику:

    # Используем функцию из предыдущего блока, чтобы определить 100 
    # координат для нашей окружности.
    circle <- circleFun(c(0, 0), 1, npoints = 100)
    graph <- graph +
        geom_path(aes(x, y), circle)
    graph

<img src="pi_calculation_files/figure-markdown_strict/unnamed-chunk-6-1.png" style="display: block; margin: auto;" />

Теперь раскрасим все точки, выходящие за пределы окружности, в красный
цвет. Такие точки определить довольно легко: стоит лишь проверить
расстояние между нашими точками и центром системы координат через
теорему Пифагора. Если расстояние больше радиуса нашей окружности, то
точки находятся за пределами окружности:

    dist <- x^2 + y^2 # рассчитываем дистанции
    a <- ifelse(dist < 1, 1, 0)
    data <- cbind(data, a)
    graph +
        geom_point(aes(color = as.factor(a))) +
        scale_color_manual(values = c("Red", "Blue")) +
        theme(legend.position = "none")

<img src="pi_calculation_files/figure-markdown_strict/unnamed-chunk-7-1.png" style="display: block; margin: auto;" />

Отлично, мы почти у цели! Теперь математический трюк: оказывается,
отношение между количеством точек внутри окружности и общим количеством
точек приблизительно равно отношению площади нашей окружности и площади
квадрата! Здесь можно использовать следующую грубую аналогию:
представим, что мы использовали в нашем эксперименте не 10 точек, а
10000. Т.к. их координаты появляются равновероятно, то они будут
заполнять пространство нашего квадрата равномерно:

<img src="pi_calculation_files/figure-markdown_strict/unnamed-chunk-8-1.png" style="display: block; margin: auto;" />

Наши 10000 координат как бы заполняют все пространство квардата и
“отражают” его площадь. Теперь раскрасим в красный те точки, которые
выходят за пределы нашей окружности с радиусом 1:

<img src="pi_calculation_files/figure-markdown_strict/unnamed-chunk-9-1.png" style="display: block; margin: auto;" />

Координаты, оставшиеся внутри нашей окружности, как бы “отражают” ее
площадь. Это, конечно, нестрогое математическое доказательство нашего
математического трюка, но теперь у нас есть хотя бы интуитивное
представление того, почему этот трюк работает. Теперь осталось записать
приблизительное равенство наших отношений:

<center>
$\\frac{S\_{круга}}{S\_{квадрата}}\\approx\\frac{n-k}{n}$, *где n –
количество всех точек, а k – количество всех точек, выходящих за пределы
окружности радиусом 1 (или всех точек, которые находятся на расстоянии
&gt; 1 от центра координатной плоскости)*
</center>

Преобразуем уравнение и выведем искомое число *π*:

<center>
$\\frac{\\pi\*r^2}{4\*r^2}\\approx\\frac{n-k}{n}\\implies\\pi\\approx4\*\\frac{n-k}{n}$
</center>

### Решение проблемы

Теперь вернемся к нашему примеру с десятью точками:

<img src="pi_calculation_files/figure-markdown_strict/unnamed-chunk-10-1.png" style="display: block; margin: auto;" />

На графике 3 точки выходят за пределы окружности (т.е. их расстояние до
центра координатной плоскости больше 1), значит n = 10 и k = 3.
Подставляем значения в выведенную формулу расчета числа *π*:

<center>
$\\pi\\approx4\*\\frac{n-k}{n}\\implies\\pi\\approx4\*\\frac{10-3}{10}\\implies\\pi\\approx2.8$
</center>

Получили число 2.8 – близко к 3.14, но недостаточно точно. Чтобы
увеличить точность расчетов, можно увеличить количество генерируемых
случайных велечин, т.е. увеличить количество используемых точек. Теперь
мы можем определить функцию общего вида для решения поставленной
проблемы:

    calc_pi <- function(n) {
        x <- runif(n, min = -1, max = 1)
        y <- runif(n, min = -1, max = 1)
        dist <- x^2 + y^2
        a <- ifelse(dist < 1, 1, 0)
        4*sum(a)/length(a)
    }

Используем нашу новую функцию *calc\_pi* для подсчета *π* c 100, 1000,
10000, 100000, 1000000 точками:

    set.seed(30)
    result <- sapply(c(100, 1000, 10000, 100000, 1000000), calc_pi)
    names(result) <- paste(as.character(c(100, 1000, 10000, 100000, 1000000)), "точек")
    result

    ##   100 точек  1000 точек 10000 точек 1e+05 точек 1e+06 точек 
    ##    2.760000    3.104000    3.170000    3.134120    3.142196

Как мы видим, с увеличением количества точек, наша точность рассчетов
числа *π* растет. В данном случае с миллионом точек мы даже верно попали
в два числа после запятой. Задача решена! Жизнь постоянно подкидывает
нам странные ситуации и обстоятельства: вдруг так случится (кто
знает??), что у вас под рукой не окажется числа *π*, но при этом будет
одна единственная функция генерации случайных чисел в R??? Теперь вы
знаете, что делать!

### Немного математической статистики

Вообще результат с точностью в два знака после запятой не такой уж
точный. Давайте еще сильнее уточним число *π* с уже помощью выведенного
приема. Будем использовать *calc\_pi* c 100000 точками, и повторим
функцию 1000 раз. Выведем десять первых полученных значений:

    results <- numeric(1000)
    for(i in 1:length(results)) {
        results[i] <- calc_pi(100000)
    }
    head(results, 10)

    ##  [1] 3.14148 3.13796 3.14152 3.14436 3.15864 3.13696 3.13980 3.14000 3.13376
    ## [10] 3.13812

Мы получили вектор из 1000 рассчетов числа *π*. Построим гистограмму
распределения полученных чисел *π*:

    hist(results, 
         xlab = paste0("Значения числа Пи (среднее значение = ", mean(results), ")"), 
         main = "Распределение значения Пи")
    abline(v = mean(results), col = "red")

<img src="pi_calculation_files/figure-markdown_strict/unnamed-chunk-14-1.png" style="display: block; margin: auto;" />
Во-первых, теперь наше рассчитанное среднее значение *π* приближено к
реальному числу *π* уже на 3 знака после запятой. А во-вторых, значения
числа *π*, как видно из гистограммы, распределены нормально. Я уверен,
что здесь задействована какая-то математико-статистическая черная магия,
о которой я пока не подозреваю.

### Discussion

Хоть задачка и решена, но в связи с ней меня терзают следующие вопросы,
на которые у меня пока не хватает сил убедительно ответить:

1.  Почему приблизительное равенство отношений площадей окружности и
    квадрата и количества точек внутри и вне окружности действительно
    работает? Т.е. интутивно и с помощью графиков этот трюк
    действительно понятен, но хотелось бы получить его какое-то более
    строгое математическое доказательство. Опять же, интутивно кажется,
    что оно должно быть;
2.  Почему наше *π*-распределение имеет форму нормального? Наверное,
    здесь как-то задействована центральная предельная теорема, ну или в
    целом математическая статистика, но у меня опять же, пока не хватает
    сил это грамотно математически проинтерпретировать;

[1] Cаму задачу и ее математическое решение я нашел в одном из
видеороликов ютуб-канала Jom’ы:
<a href="https://youtu.be/pvimAM_SLic" class="uri">https://youtu.be/pvimAM_SLic</a>

[2] <a href="https://stackoverflow.com/questions/6862742/draw-a-circle-with-ggplot2/6863365" class="uri">https://stackoverflow.com/questions/6862742/draw-a-circle-with-ggplot2/6863365</a>
