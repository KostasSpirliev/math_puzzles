---
title: <center> Расчет числа $\pi$ с помощью равномерного распределения вероятностей </center>
date: <p align="right"><font size = 4> 14.06.2020 </font size></p>
output: html_document
---

```{r echo = FALSE, include = FALSE}
knitr::opts_chunk$set(fig.width = 5, fig.height = 5, fig.align = "center") 
```

### **Постановка проблемы**

Данная работа является реализацией решения следующей задачки, 
которая показалась мне занимательной[^1]:\n

<center> *"Представьте, что единственное, что у вас есть -- это функция генерации случайных чисел из равномерного вероятностного распределения. Рассчитайте с помощью него число $\pi$."*</center> \n

Соответственно, для решения задачи в R, нам необходимо пользоваться исключительно функцией *runif* (**r**andom **unif**orm distribution). Однако перед показом непосредственно самого решения, я пошагово и с помощью графиков (для наглядности) покажу саму идею решения. На этом этапе я буду пользоваться любыми функциями.


[^1]: Cаму задачу и ее математическое решение я нашел в одном из видеороликов ютуб-канала Jom'ы:
<https://youtu.be/pvimAM_SLic>

### **На пути к решению проблемы**

Создадим два вектора *x* и *y* по 10 случайных значений в каждом, в области значений от -1 до 1.

```{r}
set.seed(11)
x <- runif(10, -1, 1)
y <- runif(10, -1, 1)
cbind(x, y)
```

Значения векторов можно представить как координаты для 10 точек соответственно.
Причем они не могут выйти за пределы $x\in[-1;1]$ и $y\in[-1;1]$. Расставим точки на графике,
а обозначенные ограничения отразим с помощью квадрата (со стороной, равной, соответственно, двум):

```{r echo = FALSE, include = FALSE}
# Для объявлении пакета ggplot2 в текущей сессии
if(!require(ggplot2)) {
    install.packages("ggplot2")
    library(ggplot2)
} else {
    library(ggplot2)
}
```

```{r}
data <- data.frame(x = x, y = y)
graph <- ggplot(data, aes(x, y)) +
    geom_point(color = "blue") +
    geom_rect(aes(xmin = -1, ymin = -1, ymax = 1, xmax = 1),
              color = "black",
              fill = NA)
graph
```

Теперь построим окружность с центром, совпадающим с центром координатной плоскости, и с радиусом 1.
Интересно, что ggplot2 не имеет готовый geom для построения окружностей, поэтому с небольшой
помощью StackOverflow предварительно определим функцию для создания координат окружности[^2]:

[^2]: <https://stackoverflow.com/questions/6862742/draw-a-circle-with-ggplot2/6863365>

```{r}
circleFun <- function(center = c(0,0), r = 1, npoints = 100) {
        tt <- seq(0,2*pi,length.out = npoints)
        xx <- center[1] + r * cos(tt)
        yy <- center[2] + r * sin(tt)
        return(data.frame(x = xx, y = yy))
}
```

**NB!** Обратим внимание, что внутри только что определенной функции мы все-таки обратились к числу
$\pi$!! Это можно оправдать тем, что именно это число $\pi$ мы используем
только для того, чтобы нарисовать окружность (в целом, это не необходимо для построения окружности на бумаге с карандашом/циркулем). Но это, возможно, не самый убедительный аргумент. Самый главный состоит в том, что все графики здесь -- это всего лишь демонстрации идеи, которая чуть позже будет определена математически (как я и обещал в самом начале!). Без круга можно легко обойтись, и на данном этапе он служит лишь наглядности.\n

Строим окружность к предыдущему графику:

```{r}
# Используем функцию из предыдущего блока, чтобы определить 100 
# координат для нашей окружности.
circle <- circleFun(c(0, 0), 1, npoints = 100)
graph <- graph +
    geom_path(aes(x, y), circle)
graph
```

Теперь раскрасим все точки, выходящие за пределы окружности, в красный цвет. Такие точки определить довольно легко: стоит лишь проверить расстояние между нашими точками и центром системы координат через теорему Пифагора. Если расстояние больше радиуса нашей окружности, то точки находятся за пределами окружности:

```{r}
dist <- x^2 + y^2 # рассчитываем дистанции
a <- ifelse(dist < 1, 1, 0)
data <- cbind(data, a)
graph +
    geom_point(aes(color = as.factor(a))) +
    scale_color_manual(values = c("Red", "Blue")) +
    theme(legend.position = "none")
```

Отлично, мы почти у цели! Теперь математический трюк: оказывается, отношение между количеством точек внутри окружности и общим количеством точек приблизительно равно отношению площади нашей окружности к площади квадрата! Здесь можно использовать следующую грубую аналогию: представим, что мы использовали в нашем эксперименте не 10 точек, а 10000. Т.к. их координаты появляются равновероятно, то они будут заполнять пространство нашего квадрата равномерно:

```{r echo = FALSE, cache = TRUE}
x1 <- runif(10000, min = -1, max = 1)
y1 <- runif(10000, min = -1, max = 1)
dist1 <- x1^2 + y1^2
a1 <- ifelse(dist1 < 1, 1, 0)
data1 <- data.frame(x = x, y = y, dist = dist1, a = a1)
    
graph1 <- ggplot(data1, aes(x = x1, y = y1)) +
    geom_point(color = "blue") +
    geom_rect(aes(xmin = -1, ymin = -1, xmax = 1, ymax = 1), 
                 color = "black",
                 fill = NA)
graph1
```

Наши 10000 координат как бы заполняют все пространство квардата и "отражают" его площадь. Теперь раскрасим в красный те точки, которые выходят за пределы нашей окружности с радиусом 1:

```{r echo = FALSE, cahce = TRUE}
graph1 +
    geom_point(aes(color = as.factor(a1))) +
    scale_color_manual(values = c("Red", "Blue")) +
        theme(legend.position = "none")
```

Координаты, оставшиеся внутри нашей окружности, как бы "отражают" ее площадь. Так и получается, что отношение площади квадрата к площади круга приблизительно равно отношению точек внутри круга к всем используемым точкам. Это, конечно, нестрогое математическое доказательство нашего математического трюка, но теперь у нас есть хотя бы интуитивное представление того, почему этот трюк работает. Теперь осталось записать приблизительное равенство наших отношений:\n

<center> $\frac{S_{круга}}{S_{квадрата}}\approx\frac{n-k}{n}$, *где n -- количество всех точек, а k -- количество всех точек, выходящих за пределы окружности радиусом 1 (или всех точек, которые находятся на расстоянии > 1 от центра координатной плоскости)* </center> \n

Преобразуем уравнение и выведем искомое число $\pi$:\n

<center> $\frac{\pi*r^2}{4*r^2}\approx\frac{n-k}{n}\implies\pi\approx4*\frac{n-k}{n}$ </center>

### Решение проблемы

Теперь вернемся к нашему примеру с десятью точками:

```{r echo = FALSE}
graph +
    geom_point(aes(color = as.factor(a))) +
    scale_color_manual(values = c("Red", "Blue")) +
    theme(legend.position = "none")
```

На графике 3 точки выходят за пределы окружности (т.е. их расстояние до центра координатной плоскости больше 1), значит n = 10 и k = 3. Подставляем значения в выведенную формулу расчета числа $\pi$:

<center> $\pi\approx4*\frac{n-k}{n}\implies\pi\approx4*\frac{10-3}{10}\implies\pi\approx2.8$ </center>

Получили число 2.8 -- близко к 3.14, но недостаточно точно. Чтобы увеличить точность расчетов, можно увеличить количество генерируемых случайных велечин, т.е. увеличить количество используемых точек. Теперь мы можем определить функцию общего вида для решения поставленной проблемы:

```{r}
calc_pi <- function(n) {
    x <- runif(n, min = -1, max = 1)
    y <- runif(n, min = -1, max = 1)
    dist <- x^2 + y^2
    a <- ifelse(dist < 1, 1, 0)
    4*sum(a)/length(a)
}
```

Используем нашу новую функцию *calc_pi* для подсчета $\pi$ c 100, 1000, 10000, 100000, 1000000 точками:

```{r}
set.seed(30)
result <- sapply(c(100, 1000, 10000, 100000, 1000000), calc_pi)
names(result) <- paste(as.character(c(100, 1000, 10000, 100000, 1000000)), "точек")
result
```

Как мы видим, с увеличением количества точек, наша точность рассчетов числа $\pi$ растет. В данном случае с миллионом точек мы даже верно попали в два числа после запятой. Задача решена! Вдруг так случится (кто знает??), что у вас под рукой не окажется числа $\pi$, но при этом будет одна единственная функция генерации случайных чисел в R??? Теперь вы знаете, что делать!

### Немного математической статистики

Вообще результат с точностью в два знака после запятой не такой уж точный. Давайте еще сильнее уточним число $\pi$ уже с помощью выведенного приема. Будем использовать *calc_pi* c 100000 точками, и повторим функцию 1000 раз. Выведем десять первых полученных значений:

```{r cache = TRUE}
results <- numeric(1000)
for(i in 1:length(results)) {
    results[i] <- calc_pi(100000)
}
head(results, 10)
```

Мы получили вектор из 1000 рассчетов числа $\pi$. Построим гистограмму распределения полученных чисел $\pi$:

```{r}
hist(results, 
     xlab = paste0("Значения числа Пи (среднее значение = ", mean(results), ")"), 
     main = "Распределение значения Пи")
abline(v = mean(results), col = "red")
```
Во-первых, теперь наше рассчитанное среднее значение $\pi$ приближено к реальному числу $\pi$ уже на 3 знака после запятой. А во-вторых, значения числа $\pi$, как видно из гистограммы, распределены нормально. Я уверен, что здесь задействована какая-то математико-статистическая черная магия, о которой я пока не подозреваю.

### Discussion

Хоть задачка и решена, но в связи с ней меня терзают следующие вопросы, на которые у меня пока не хватает сил убедительно ответить:

1. Почему приблизительное равенство отношений площадей окружности и квадрата и количества точек внутри и вне окружности действительно работает? Т.е. интутивно и с помощью графиков этот трюк действительно понятен, но хотелось бы получить его какое-то более строгое математическое доказательство. Опять же, интутивно кажется, что оно должно быть;
2. Почему наше $\pi$-распределение имеет форму нормального? Наверное, здесь как-то задействована центральная предельная теорема, ну или в целом математическая статистика, но у меня опять же, пока не хватает сил это грамотно математически проинтерпретировать;